# ADR 001: Использование Clean Architecture

## Статус

Принято

## Контекст

Проект GoTechPasport предназначен для долгосрочной поддержки и развития. Необходима архитектура, которая:

1. Обеспечивает четкое разделение ответственности
2. Позволяет легко тестировать бизнес-логику
3. Минимизирует зависимости между слоями
4. Упрощает замену внешних зависимостей (GUI, БД, генераторы документов)
5. Облегчает добавление новой функциональности без изменения существующего кода

## Решение

Использовать Clean Architecture с четырьмя слоями:

### 1. Domain Layer (internal/domain/)

**Ответственность:** Бизнес-логика и доменные сущности

**Содержит:**
- `entity/` — доменные сущности (TechnicalPassport, Building, Address, Owner, Room)
- `repository/` — интерфейсы репозиториев для доступа к данным
- `service/` — интерфейсы доменных сервисов (генерация документов, валидация)

**Зависимости:** Нет внешних зависимостей

**Принципы:**
- Сущности содержат только данные и бизнес-правила
- Интерфейсы определяют контракты для внешних слоев
- Валидация на уровне доменных правил

### 2. Use Case Layer (internal/usecase/)

**Ответственность:** Сценарии использования приложения

**Содержит:**
- `passport/` — операции с техническим паспортом (создание, обновление, экспорт)
- `address/` — работа с адресами (форматирование по ГАР)

**Зависимости:** Только Domain Layer

**Принципы:**
- Каждый use case — отдельная структура с методом Execute()
- Use cases оркеструют работу через интерфейсы репозиториев и сервисов
- Обработка ошибок и бизнес-логика

### 3. Adapter Layer (internal/adapter/)

**Ответственность:** Адаптация внешнего мира к use cases

**Содержит:**
- `gui/` — графический интерфейс на Fyne
- `cli/` — интерфейс командной строки (опционально)
- `presenter/` — преобразование данных для отображения

**Зависимости:** Use Case Layer, Domain Layer

**Принципы:**
- Преобразование данных между форматом UI и доменными сущностями
- Обработка пользовательского ввода
- Не содержит бизнес-логики

### 4. Infrastructure Layer (internal/infrastructure/)

**Ответственность:** Реализация интерфейсов из Domain Layer

**Содержит:**
- `document/` — генерация PDF/DOCX документов
- `storage/` — хранилища данных (файлы, БД)
- `template/` — загрузка и работа с шаблонами

**Зависимости:** Domain Layer (только интерфейсы)

**Принципы:**
- Реализация интерфейсов репозиториев и сервисов
- Работа с внешними библиотеками и API
- Изолирована от бизнес-логики

## Правило зависимостей

```
Infrastructure → Adapters → Use Cases → Domain
       ↓            ↓           ↓
    Domain      Domain      Domain
```

**Ключевое правило:** Зависимости направлены только внутрь. Внутренние слои не знают о внешних.

## Преимущества

1. **Тестируемость** — бизнес-логика легко тестируется изолированно через mock-интерфейсы
2. **Независимость от фреймворков** — можно заменить Fyne на другой GUI без изменения логики
3. **Независимость от БД** — легко переключаться между файловым хранилищем и базой данных
4. **Независимость от внешних библиотек** — генераторы PDF/DOCX легко заменяемы
5. **Поддерживаемость** — четкое разделение ответственности упрощает понимание кода
6. **Расширяемость** — новая функциональность добавляется без изменения существующего кода

## Недостатки

1. **Больше кода** — требуется больше интерфейсов и структур
2. **Начальная сложность** — требует понимания архитектурных принципов
3. **Overhead для простых операций** — даже простые операции проходят через несколько слоев

## Альтернативы

1. **MVC** — проще, но сложнее тестировать и поддерживать в долгосрочной перспективе
2. **Layered Architecture** — менее строгое разделение, допускает больше coupling
3. **Hexagonal Architecture** — похожа на Clean Architecture, но с другой терминологией

## Решение

Преимущества Clean Architecture перевешивают недостатки для проекта, рассчитанного на долгосрочную поддержку. Дополнительная сложность компенсируется:

- Четкой структурой проекта
- Упрощенным тестированием
- Возможностью независимого развития компонентов
- Минимизацией технического долга

## Последствия

1. Все новые функции должны следовать слоистой архитектуре
2. Интерфейсы определяются в Domain Layer
3. Реализации — в Infrastructure Layer
4. Use Cases не зависят от конкретных реализаций
5. GUI/CLI зависят только от Use Cases
6. Каждый слой имеет свои тесты

## Дата

2026-02-16

## Автор

Zakir Alekperov
